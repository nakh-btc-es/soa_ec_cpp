function stInfo = atgcv_m01_type_info_get(stEnv, hType, bWithExtendedInfo)
% Get info about the provided type
%
% function stInfo = atgcv_m01_type_info_get(stEnv, hType, bWithExtendedInfo)
%
%   INPUT               DESCRIPTION
%     stEnv              (struct)       environment struct
%     hType              (DD handle)    DD handle to "Type"
%     bWithExtendedInfo  (bool)         if set to true, function retrieves also the Min/Max Info for the BaseType
%                                       (optional: default == false)
%   OUTPUT              DESCRIPTION
%     stInfo            (struct)       info about type of variable
%       .sUser            (string)       user type of variable
%       .sBase            (string)       base type of variable
%       .sUserDest        (string)       if sBase=='Pointer', the user type of the destination variable, otherwise empty
%       .sBaseDest        (string)       if sBase=='Pointer', the base type of the destination variable, otherwise empty
%       .sStructTag       (string)       if sBase=='Struct' or sBaseDest=='Struct', the tag of the struct variable, 
%                                        otherwise empty (note: in context of AUTOSAR the tag may be missing even if
%                                        Type is a Struct)
%       .bHasTypedef      (bool)         TRUE, if UserType has a typedef
%       .astEnumElements  (struct)       array of structs, each describing a single element from an Enum type
%          .sName           (string)       name of the Enum element
%          .sValue          (string)       value of the Enum element as string
%
%       .stContstraints   (struct)       struct with info about type constraints (might be empty --> [] )
%          .stScaling       (struct)       struct with scaling info (see: ep_dd_scaling_read)
%             
% ----- extended info ------------
%       .dMin             (double)       min of TL type
%       .dMax             (double)       max of TL type
%       .bIsFloat         (bool)         TRUE if variable is float-type, otherwise FALSE   
%
%


%%
stInfo = struct( ...
    'sUser',           '', ...
    'sBase',           '', ...
    'sUserDest',       '', ...
    'sBaseDest',       '', ...
    'sStructTag',      '', ...
    'bHasTypedef',     true, ...
    'astEnumElements', [], ...
    'stConstraints',   []);

if (nargin < 3)
    bWithExtendedInfo = false;
end

stInfo.sUser = atgcv_mxx_dsdd(stEnv, 'GetAttribute', hType, 'Name');
stInfo.sBase = atgcv_mxx_dsdd(stEnv, 'GetBaseType', hType);

stInfo.bHasTypedef = i_hasTypedef(stEnv, hType);

sBase = stInfo.sBase;
if strcmpi(stInfo.sBase, 'Pointer')
    hDestInfo        = atgcv_mxx_dsdd(stEnv, 'GetPointerDestType', hType);    
    stInfo.sUserDest = atgcv_mxx_dsdd(stEnv, 'GetAttribute', hDestInfo, 'name');
    stInfo.sBaseDest = atgcv_mxx_dsdd(stEnv, 'GetBaseType', hDestInfo);
    
    hType = hDestInfo;
    sBase = stInfo.sBaseDest;
end

% same info for base or for base_dest
if strcmpi(sBase, 'Struct')
    % for TL3.4 and higher the new RTE CodeGenerator does not produce
    % forward Tags any longer even though they are still present in the DD (see BTS/30873 and BTS/34148)
    % --> just add Tag if we have TL lower than TL3.4 or if we are not in a file generated by the AUTOSAR RTE CodeCompiler
    if ~i_isRteModule(stEnv, hType)
        sTag = atgcv_mxx_dsdd(stEnv, 'GetTag', hType);
        stInfo.sStructTag = sprintf('struct %s', sTag);
    end
end

if strcmpi(sBase, 'Enum')
    stInfo.astEnumElements = i_getEnumElements(hType);
end

stInfo.stConstraints = i_getConstraints(hType);

if bWithExtendedInfo
    stInfo.dTypeMin   = [];
    stInfo.dTypeMax   = [];
    stInfo.bIsFloat   = false;
    
    [stInfo.dMin, stInfo.dMax] = i_getTlTypeMinMax(sBase); 
    stInfo.bIsFloat = ds_isa(hType, 'floattype');
end
end


%%
function stConstraints = i_getConstraints(hType)
stConstraints = [];

bHasConstraints = dsdd('Exist', 'Constraints', 'Parent', hType);
if bHasConstraints
    hScaling = dsdd('GetConstraintsScalingRefTarget', hType);
    if ~isempty(hScaling)
        stConstraints = struct( ...
            'stScaling', ep_dd_scaling_read(hScaling));
    end
end
end


%%
function astEnumElements = i_getEnumElements(hType)
hEnumElements = dsdd('GetEnumElements', hType);
ahElements = dsdd('getChildren', hEnumElements);
nEnumElements = numel(ahElements);

astEnumElements = repmat(struct(...
    'sName', '', ...
    'sValue' , []), nEnumElements, 1);
for i = 1:nEnumElements
    hEnumElem = ahElements(i);
    astEnumElements(i).sName = dsdd('GetAttribute', hEnumElem, 'name');
    astEnumElements(i).sValue = sprintf('%d', dsdd('getValue', hEnumElem));
end
end


%%
function bIsRTE = i_isRteModule(stEnv, hVarType)
bIsRTE = false; % default case: not an RTE file but Production Code file

sPath = atgcv_mxx_dsdd(stEnv, 'GetAttribute', hVarType, 'path');
iFind = regexp(sPath, '/Typedefs/', 'once');
if isempty(iFind)
    % VariableType handle is not inside a Module (maybe in Pool area of DD)
    return;
end

sModulePath = sPath(1:iFind-1);
[bExist, hModule] = dsdd('Exist', sModulePath);
if bExist
    hModuleInfo = atgcv_mxx_dsdd(stEnv, 'GetModuleInfo', hModule);
    ahFileInfo  = atgcv_mxx_dsdd(stEnv, 'Find', hModuleInfo, ...
        'objectKind', 'FileInfo', 'property', {'name', 'FileType'});
    if ~isempty(ahFileInfo)
        sFileType = atgcv_mxx_dsdd(stEnv, 'GetFileType', ahFileInfo(1));
        bIsRTE = strcmp(sFileType, 'SimulationFrameFile');
    end
end
end


%%
function [dMin, dMax] = i_getTlTypeMinMax(sBaseType)
dMin = [];
dMax = [];
switch lower(sBaseType)
    case {'bool', 'bitfield'}
        dMin = 0;
        dMax = 1;
        
    case {'uint8', 'int8', 'uint16', 'int16', 'uint32', 'int32', 'uint64', 'int64'}
        dMin = double( intmin(lower(sBaseType)) );
        dMax = double( intmax(lower(sBaseType)) );
        
    case  'float32'
        dMax = realmax('single');
        dMin = -dMax;
        
    case  'float64'
        dMax = 1.7E+308;
        dMin = -dMax;
        
    otherwise
        % do nothing special here
end
end


%%
% current assumption deduced from DD behavior
% 1) type has typedef if it is a basetype
% 2) type has typedef if it does _not_ have a property named
% "CreateTypedef" set to false
function bHasTypedef = i_hasTypedef(stEnv, hType)
bHasTypedef = true;

if dsdd('Exist', hType, 'property', {'name', 'IsBaseType'}) 
    if logical(atgcv_mxx_dsdd(stEnv, 'GetIsBaseType', hType))
        return;
    end    
end

if dsdd('Exist', hType, 'property', {'name', 'CreateTypedef'}) 
    if ~logical(atgcv_mxx_dsdd(stEnv, 'GetCreateTypedef', hType))
        bHasTypedef = false;
    end    
end
end

